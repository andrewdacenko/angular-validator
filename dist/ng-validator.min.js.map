{"version":3,"sources":["message-bag/message-bag.js","validation-translator/validation-translator.js","validator/validator.js","ng-validator.min.js"],"names":["window","angular","undefined","module","factory","MessageBag","this","errors","prototype","add","field","message","Array","push","hasErrors","prop","hasOwnProperty","all","has","first","get","constant","locale","fallback","en","accepted","between","numeric","string","array","in","integer","max","min","not_in","regex","required","required_if","required_with","required_with_all","required_without","required_without_all","custom","attribute-name","rule-name","attributes","email","values","colors","F00","0F0","00F","service","validationTranslatorLang","validationTranslatorConfig","trans","key","parameters","replace","locales","parseLocale","i","length","getMessage","localeData","data","keys","split","filter","l","ValidationTranslator","Validator","rules","customMessages","customAttributes","explodeRules","ucwords","str","$1","toUpperCase","studlyCase","snakeCase","toLowerCase","a","b","r","make","sizeRules","numericRules","implicitRules","fallbackMessages","customValues","attribute","parseRule","isArray","parseArrayRule","parseStringRule","rule","trim","slice","indexOf","list","parseParameters","parameter","validate","parsed","value","getValue","addFailure","passes","attributeRules","fails","extend","fn","defaultMessages","doReplacements","lowerRule","inlineMessage","getInlineMessage","customKey","join","customMessage","getSizeMessage","source","messages","type","getAttributeType","anyFailingRequired","validateRequired","allRequiredFails","Object","Date","getOwnPropertyNames","validateRequiredWith","validateRequiredWithAll","validateRequiredWithout","validateRequiredWithoutAll","allFailingRequired","validateRequiredIf","validateAccepted","acceptable","validateIn","validateNotIn","validateInteger","filter_var","FILTER_VALIDATE_INT","validateNumeric","isNaN","validateBetween","requireParameterCount","size","getSize","count","Error","hasNumeric","hasRule","getStringSize","getRule","getAttribute","getAttributeList","getDisplayableValue","replaceBetween","replaceSize","replaceMin","replaceMax","replaceIn","replaceNotIn","replaceRequiredWith","replaceRequiredWithout","replaceRequiredWithoutAll","replaceRequiredIf","array_get","replaceSame","replaceDifferent","replaceDateFormat","replaceBefore","parse","replaceAfter"],"mappings":"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","file":"ng-validator.min.js","sourcesContent":["angular\n    .module('ngValidator.message-bag', [])\n    .factory('MessageBag', function () {\n        /**\n         * Create a new MessageBag instance.\n         *\n         * @return Object  MessageBag\n         */\n        function MessageBag() {\n            this.errors = {};\n        };\n\n        /**\n         * Add new error on field validation.\n         *\n         * @param  string  field\n         * @param  string  rule\n         * @param  string  message\n         * @return boolean\n         */\n        MessageBag.prototype.add = function (field, message) {\n            if (!(this.errors[field] instanceof Array)) {\n                this.errors[field] = [];\n            };\n\n            this.errors[field].push(message);\n        };\n\n        /**\n         * Check if there are any errors.\n         *\n         * @return boolean\n         */\n        MessageBag.prototype.hasErrors = function () {\n            for (var prop in this.errors) {\n                if (this.errors.hasOwnProperty(prop))\n                    return true;\n            }\n\n            return false;\n        };\n\n        /**\n         * Get all messages after validation.\n         *\n         * @return Object\n         */\n        MessageBag.prototype.all = function () {\n            return this.errors;\n        };\n\n        /**\n         * Check if there are errors at field validation.\n         *\n         * @param  string  field\n         * @return Object\n         */\n        MessageBag.prototype.has = function (field) {\n            return this.errors[field] ? true : false;\n        };\n\n        /**\n         * Get first error on field validation.\n         *\n         * @param  string  field\n         * @return Object\n         */\n        MessageBag.prototype.first = function (field) {\n            if (this.has(field)) {\n                return this.errors[field][0];\n            }\n\n            return '';\n        };\n\n        /**\n         * Get all the field validation errors.\n         *\n         * @param  string  field\n         * @return Object\n         */\n        MessageBag.prototype.get = function (field) {\n            if (this.has(field)) {\n                return this.errors[field];\n            };\n\n            return [];\n        };\n\n        return MessageBag;\n    });","angular\n    .module('ngValidator.validation-translator', [])\n    .constant('validationTranslatorLang', {\n        locale: 'en',\n        fallback: 'en'\n    })\n    .constant('validationTranslatorConfig', {\n        \"en\": {\n            \"accepted\": \"The :attribute must be accepted.\",\n            \"between\": {\n                \"numeric\": \"The :attribute must be between :min and :max.\",\n                \"string\": \"The :attribute must be between :min and :max characters.\",\n                \"array\": \"The :attribute must have between :min and :max items.\",\n            },\n            \"in\": \"The selected :attribute is invalid.\",\n            \"integer\": \"The :attribute must be an integer.\",\n            \"max\": {\n                \"numeric\": \"The :attribute may not be greater than :max.\",\n                \"string\": \"The :attribute may not be greater than :max characters.\",\n                \"array\": \"The :attribute may not have more than :max items.\",\n            },\n            \"min\": {\n                \"numeric\": \"The :attribute must be at least :min.\",\n                \"string\": \"The :attribute must be at least :min characters.\",\n                \"array\": \"The :attribute must have at least :min items.\",\n            },\n            \"not_in\": \"The selected :attribute is invalid.\",\n            \"numeric\": \"The :attribute must be a number.\",\n            \"regex\": \"The :attribute format is invalid.\",\n            \"required\": \"The :attribute field is required.\",\n            \"required_if\": \"The :attribute field is required when :other is :value.\",\n            \"required_with\": \"The :attribute field is required when :values is present.\",\n            \"required_with_all\": \"The :attribute field is required when :values is present.\",\n            \"required_without\": \"The :attribute field is required when :values is not present.\",\n            \"required_without_all\": \"The :attribute field is required when none of :values are present.\",\n\n            // Developers can set custom validation messages on some attributes\n            // validation rules\n            \"custom\": {\n                \"attribute-name\": {\n                    \"rule-name\": \"custom-message\",\n                },\n            },\n\n            // Developers can set displayable value for some attributes\n            \"attributes\": {\n                \"email\": \"Email address\",\n            },\n\n            // As an example just set displayable value for colors attribute and\n            // its values\n            \"values\": {\n                \"colors\": {\n                    \"F00\": \"Red\",\n                    \"0F0\": \"Green\",\n                    \"00F\": \"Blue\",\n                },\n            },\n        }\n    })\n    .service('ValidationTranslator', ['validationTranslatorLang', 'validationTranslatorConfig',\n        function ValidationTranslator(validationTranslatorLang, validationTranslatorConfig) {\n            /**\n             * Get the translation for a given key.\n             *\n             * @param  {String}  key\n             * @param  {Object}  parameters\n             * @param  {String}  locale\n             * @return {String}\n             */\n            this.trans = function trans(key, parameters, locale) {\n                parameters = parameters || {};\n                locale = locale || null;\n\n                return this.get(key, parameters, locale);\n            };\n\n            /**\n             * Get the translation for the given key.\n             *\n             * @param  {String}  key\n             * @param  {Object}  replace\n             * @param  {String}  locale\n             * @return {String}\n             */\n            this.get = function get(key, replace, locale) {\n                // Here we will get the locale that should be used for the\n                // language. If one was not passed, we will use the default\n                // locale. Then, we can get the  message and return.\n                var locales = this.parseLocale(locale);\n\n                var message = null;\n                for (var i = 0; i < locales.length; i++) {\n                    var message = this.getMessage(locales[i], key, replace);\n\n                    if (message) break;\n                };\n\n                // If the message doesn't exist, we will return back the key\n                // which was requested as that will be quick to spot in the UI\n                // if language keys are wrong or missing from the translator's\n                // language config. Otherwise we can return the message.\n                if (!message) return key;\n                return message;\n            };\n\n            /**\n             * Retrieve a language line out the loaded Object.\n             *\n             * @param  {String}  locale\n             * @param  {String}  key\n             * @param  {Object}  replace\n             * @return {String|undefined}\n             */\n            this.getMessage = function getMessage(locale, key, replace) {\n                var message;\n\n                var localeData = validationTranslatorConfig[locale];\n\n                if (localeData) {\n                    var data = localeData;\n                    var keys = key.split('.');\n\n                    for (var i = 0; i < keys.length; i++) {\n                        if (data[keys[i]]) {\n                            data = data[keys[i]];\n                        } else {\n                            return;                            \n                        }\n                    };\n\n                    message = data;\n                };\n\n                return message;\n            };\n\n            /**\n             * Get the array of locales to be checked.\n             *\n             * @param  {String|null}  locale\n             * @return {Array}\n             */\n            this.parseLocale = function parseLocale(locale) {\n                if (locale !== null) {\n                    return [locale, this.fallback].filter(function (l) {\n                        return l;\n                    });\n                };\n\n                return [validationTranslatorLang.locale, validationTranslatorLang.fallback].filter(function (l) {\n                    return l;\n                });\n            };\n        }\n    ]);","angular\n    .module('ngValidator.validator', ['ngValidator.message-bag', 'ngValidator.validation-translator'])\n    .factory('Validator', ['MessageBag', 'ValidationTranslator',\n        function (MessageBag, ValidationTranslator) {\n            /**\n             * Create a new Validator instance with `new Validator(...args)`.\n             *\n             * @param {Object} data           Data to be validated\n             * @param {Object} rules          Set of rules\n             * @param {Object} customMessages Custom messages\n             * @param {Object} customAttributes   Custom messages\n             * @return {Validator}            Validator\n             */\n            function Validator(data, rules, customMessages, customAttributes) {\n                this.data = data;\n                this.rules = this.explodeRules(rules);\n                this.customMessages = customMessages || {};\n                this.customAttributes = customAttributes || {};\n            };\n\n            /**\n             * Or create new validator instance by calling\n             * Validator.make(...args).\n             *\n             * @param {Object} data           Data to be validated\n             * @param {Object} rules          Set of rules\n             * @param {Object} customMessages Custom messages\n             * @param {Object} customAttributes   Custom messages\n             * @return {Validator}            Validator\n             */\n            Validator.make = function (data, rules, customMessages, customAttributes) {\n                return new Validator(data, rules, customMessages, customAttributes);\n            };\n\n            /**\n             * The size related validation rules.\n             *\n             * @attribute {Array}\n             */\n            Validator.prototype.sizeRules = ['Size', 'Between', 'Min', 'Max'];\n\n            /**\n             * The numeric related validation rules.\n             *\n             * @attribute {Array}\n             */\n            Validator.prototype.numericRules = ['Numeric', 'Integer'];\n\n            /**\n             * The validation rules that imply the attribute is required.\n             *\n             * @attribute {Array}\n             */\n            Validator.prototype.implicitRules = ['Required', 'RequiredWith', 'RequiredWithAll', 'RequiredWithout', 'RequiredWithoutAll', 'RequiredIf', 'Accepted'];\n\n            /**\n             * Fallback messages\n             *\n             * @attribute {Object}\n             */\n            Validator.prototype.fallbackMessages = {};\n\n            /**\n             * The array of custom attribute names.\n             *\n             * @attribute {Array}\n             */\n            Validator.prototype.customAttributes = {};\n            /**\n             * The array of custom displayabled values.\n             *\n             * @attribute {Array}\n             */\n            Validator.prototype.customValues = {};\n\n            /**\n             * Explode the rules into an array of rules.\n             *\n             * @param  {Object}  rules\n             * @return {Object}\n             */\n            Validator.prototype.explodeRules = function (rules) {\n                for (var attribute in rules) {\n                    rules[attribute] = (typeof rules[attribute] === 'string') ? rules[attribute].split('|') : rules[attribute];\n                };\n\n                return rules;\n            };\n\n            /**\n             * Extract the rule name and parameters from a rule.\n             *\n             * @param  {Array|String}  rules\n             * @return {Object}\n             */\n            Validator.prototype.parseRule = function (rules) {\n                if (Array.isArray(rules)) {\n                    return this.parseArrayRule(rules);\n                };\n\n                return this.parseStringRule(rules);\n            };\n\n            /**\n             * Parse an array based rule.\n             *\n             * @param  {Array}  rules\n             * @return {Object}\n             */\n            Validator.prototype.parseArrayRule = function (rules) {\n                return {\n                    rule: studlyCase(rules[0].trim()),\n                    parameters: rules.slice(1)\n                };\n            };\n\n            /**\n             * Parse a string based rule.\n             *\n             * @param  {String}  rules\n             * @return {Array}\n             */\n            Validator.prototype.parseStringRule = function (rules) {\n                var parameters = [];\n\n                // The format for specifying validation rules and parameters follows an\n                // easy {rule}:{parameters} formatting convention. For instance the\n                if (rules.indexOf(':') !== -1) {\n                    var list = rules.split(':');\n                    rules = list[0];\n                    var parameters = this.parseParameters(rules, list[1]);\n                }\n\n                return {\n                    rule: studlyCase(rules.trim()),\n                    parameters: parameters\n                };\n            };\n\n            /**\n             * Parse a parameter list.\n             *\n             * @param  {String}   rule\n             * @param  {String}   parameter\n             * @return {Array}\n             */\n            Validator.prototype.parseParameters = function (rule, parameter) {\n                if (rule.toLowerCase() == 'regex') return [parameter];\n                return parameter.split(',');\n            }\n\n            /**\n             * Validate a given attribute against a rule.\n             *\n             * @param  {String}   attribute\n             * @param  {String}   rule\n             * @return {Void}\n             */\n            Validator.prototype.validate = function (attribute, rule) {\n                var parsed = this.parseRule(rule);\n\n                if (parsed.rule === '') return;\n\n                var value = this.getValue(attribute);\n\n                if (!this['validate' + parsed.rule](attribute, value, parsed.parameters)) {\n                    this.addFailure(attribute, parsed.rule, parsed.parameters);\n                };\n            };\n\n            /**\n             * Determine if the data passes the validation rules.\n             *\n             * @return {Boolean}\n             */\n            Validator.prototype.passes = function () {\n                this.errors = new MessageBag;\n\n                for (var attribute in this.rules) {\n                    var attributeRules = this.rules[attribute];\n\n                    for (var i = 0; i < attributeRules.length; i++) {\n                        this.validate(attribute, attributeRules[i]);\n                    }\n\n                };\n\n                return !this.errors.hasErrors();\n            };\n\n            /**\n             * Determine if the data fails the validation rules.\n             *\n             * @return {Boolean}\n             */\n            Validator.prototype.fails = function () {\n                return !this.passes();\n            };\n\n            /**\n             * Register a custom validator rule.\n             *\n             * @param  {String}    rule\n             * @param  {Function}  fn\n             * @param  {String}    message\n             * @return {Void}\n             */\n            Validator.extend = function (rule, fn, message) {\n                rule = studlyCase(rule);\n                Validator.prototype['validate' + rule] = fn;\n                Validator.prototype.defaultMessages[rule] = message || '';\n            };\n\n            /**\n             * Add a failed rule and error message to the collection.\n             *\n             * @param  {String}   attribute\n             * @param  {String}   rule\n             * @param  {Array}    parameters\n             * @return {Void}\n             */\n            Validator.prototype.addFailure = function (attribute, rule, parameters) {\n                var message = this.getMessage(attribute, rule);\n\n                message = this.doReplacements(message, attribute, rule, parameters);\n\n                this.errors.add(attribute, message);\n            };\n\n            /**\n             * Get the validation message for an attribute and rule.\n             *\n             * @param  {String}   attribute\n             * @param  {String}   rule\n             * @return {String}\n             */\n            Validator.prototype.getMessage = function (attribute, rule) {\n                var lowerRule = snakeCase(rule);\n\n                var inlineMessage = this.getInlineMessage(attribute, lowerRule);\n\n                // First we will retrieve the custom message for the\n                // validation rule if one exists. If a custom validation\n                // message is being used we'll return the custom message,\n                // otherwise we'll keep searching for a valid message.\n                if (inlineMessage) {\n                    return inlineMessage;\n                };\n\n                var customKey = [\"custom.\", attribute, '.', lowerRule].join('');\n\n                var customMessage = ValidationTranslator.trans(customKey);\n\n                // Than we check for a custom defined validation message for\n                // the attribute and rule. This allows the developer to specify\n                // specific messages for only some attributes and rules that need\n                // to get specially formed.\n                if (customMessage !== customKey) {\n                    return customMessage;\n                }\n\n                // If the rule being validated is a \"size\" rule, we will need to gather the\n                // specific error message for the type of attribute being validated such\n                // as a number, file or string which all have different message types.\n                else if (this.sizeRules.indexOf(rule) !== -1) {\n                    return this.getSizeMessage(attribute, rule);\n                };\n\n                // Than, if no developer specified messages have been set, and\n                // no other special messages apply for this rule, we will just\n                // pull the default\n                var key = lowerRule;\n                var value = ValidationTranslator.trans(key);\n\n                if (key !== value) {\n                    return value;\n                };\n\n                return this.getInlineMessage(attribute, lowerRule, this.fallbackMessages) || key;\n            };\n\n            /**\n             * Get the inmessage message for a rule if it exists.\n             *\n             * @param  {String}   attribute\n             * @param  {String}   lowerRule\n             * @param  {Array}    source\n             * @return {String}\n             */\n            Validator.prototype.getInlineMessage = function (attribute, lowerRule, source) {\n                var messages = source || this.customMessages;\n                var keys = [attribute + '.' + lowerRule, studlyCase(lowerRule)];\n\n                // First we will check for a custom message for an attribute\n                // specific rule message for the attributes, then we will check\n                // for a general custom message that is not attribute specific. If\n                // we find either we'll return it.\n                for (var key in keys) {\n                    if (messages[keys[key]] !== undefined) return messages[keys[key]];\n                }\n            };\n\n            /**\n             * Get the proper error message for an attribute and size rule.\n             *\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @return {String}\n             */\n            Validator.prototype.getSizeMessage = function (attribute, rule) {\n                var lowerRule = snakeCase(rule);\n                // There are three different types of size validations. The\n                // attribute may be either a number, file, or string so we will\n                // check a few things to know which type of value it is and\n                // return the correct line for that type.\n                var type = this.getAttributeType(attribute);\n\n                var key = [lowerRule, '.', type].join('');\n\n                return ValidationTranslator.trans(key);\n            };\n\n            /**\n             * Replace all error message place-holders with actual values.\n             *\n             * @param  {String}  message\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @param  {Array}   parameters\n             * @return {String}\n             */\n            Validator.prototype.doReplacements = function (message, attribute, rule, parameters) {\n                var message = replace(message, {\n                    attribute: attribute\n                });\n\n                if (this['replace' + rule] !== undefined) {\n                    message = this['replace' + rule](message, attribute, rule, parameters);\n                };\n\n                return message;\n            };\n\n            /**\n             * Get the value of a given attribute.\n             *\n             * @param  {String}   attribute\n             * @return {Mixed}\n             */\n            Validator.prototype.getValue = function (attribute) {\n                return this.data[attribute];\n            };\n\n            /**\n             * Determine if any of the given attributes fail the required test.\n             *\n             * @param  {Array}  attributes\n             * @return {Boolean}\n             */\n            Validator.prototype.anyFailingRequired = function (attributes) {\n                for (var key in attributes) {\n                    if (!this.validateRequired(key, this.getValue(key))) {\n                        return true;\n                    };\n                };\n\n                return false;\n            };\n\n            /**\n             * Determine if all of the given attributes fail the required test.\n             *\n             * @param  {Array}    attributes\n             * @return {Boolean}\n             */\n            Validator.prototype.allRequiredFails = function (attributes) {\n                for (var key in attributes) {\n                    if (this.validateRequired(key, this.getValue(key))) {\n                        return false;\n                    };\n                };\n\n                return true;\n            };\n\n            /**\n             * Validate that a required attribute exists.\n             *\n             * @param  {String}   attribute\n             * @param  {Mixed}    value\n             * @return {Boolean}\n             */\n            Validator.prototype.validateRequired = function (attribute, value) {\n                if (value === null || value === undefined) {\n                    return false\n                } else if (typeof value === 'string') {\n                    if (value.trim() === '') {\n                        return false;\n                    };\n                } else if (value instanceof Array) {\n                    if (value.length < 1) {\n                        return false\n                    };\n                } else if (value instanceof Object && !(value instanceof Date)) {\n                    if (Object.getOwnPropertyNames(value).length === 0) {\n                        return false;\n                    };\n                };\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute exists when any other attribute exists.\n             *\n             * @param  {String}   attribute\n             * @param  {Mixed}    value\n             * @param  {Array}    parameters\n             * @return {Boolean}\n             */\n            Validator.prototype.validateRequiredWith = function (attribute, value, parameters) {\n                if (!this.allRequiredFails(parameters)) {\n                    return this.validateRequired(attribute, value);\n                };\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute exists when all other attributes exists.\n             *\n             * @param  {String}  attribute\n             * @param  {Mixed}   value\n             * @param  {Mixed}   parameters\n             * @return {Boolean}\n             */\n            Validator.prototype.validateRequiredWithAll = function (attribute, value, parameters) {\n                if (!this.anyFailingRequired(parameters)) {\n                    return this.validateRequired(attribute, value);\n                };\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute exists when another attribute does not.\n             *\n             * @param  {String}  attribute\n             * @param  {Mixed}   value\n             * @param  {Mixed}   parameters\n             * @return {Boolean}\n             */\n            Validator.prototype.validateRequiredWithout = function (attribute, value, parameters) {\n                if (this.anyFailingRequired(parameters)) {\n                    return this.validateRequired(attribute, value);\n                };\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute exists when all other attributes do not.\n             *\n             * @param  {String}  attribute\n             * @param  {Mixed}   value\n             * @param  {Mixed}   parameters\n             * @return {Boolean}\n             */\n            Validator.prototype.validateRequiredWithoutAll = function (attribute, value, parameters) {\n                if (this.allFailingRequired(parameters)) {\n                    return this.validateRequired(attribute, value);\n                };\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute exists when other attribute has certain value.\n             *\n             * @param  {String}   attribute\n             * @param  {Mixed}    value\n             * @param  {Array}    parameters\n             * @return {Boolean}\n             */\n            Validator.prototype.validateRequiredIf = function (attribute, value, parameters) {\n                if (this.getValue(parameters[0]) === parameters[1]) {\n                    return this.validateRequired(attribute, value);\n                };\n\n                return true;\n            };\n\n            /**\n             * Validate that an attribute was \"accepted\".\n             *\n             * This validation rule implies the attribute is \"required\".\n             *\n             * @param  {String}   attribute\n             * @param  {Mixed}    value\n             * @return {Boolean}\n             */\n            Validator.prototype.validateAccepted = function (attribute, value) {\n                var acceptable = ['yes', 'on', '1', 1, true, 'true'];\n\n                return (this.validateRequired(attribute, value) && acceptable.indexOf(value) !== -1);\n            };\n\n            /**\n             * Validate an attribute is contained within a list of values.\n             *\n             * @param  {String}  attribute\n             * @param  {Mixed}   value\n             * @param  {Array}   parameters\n             * @return {Boolean}\n             */\n            Validator.prototype.validateIn = function (attribute, value, parameters) {\n                return parameters.indexOf('' + value);\n            };\n\n            /**\n             * Validate an attribute is not contained within a list of values.\n             *\n             * @param  {String}  attribute\n             * @param  {Mixed}   value\n             * @param  {Array}   parameters\n             * @return {Boolean}\n             */\n            Validator.prototype.validateNotIn = function (attribute, value, parameters) {\n                return !this.validateIn(attribute, value, parameters);\n            };\n\n            /**\n             * Validate that an attribute is an integer.\n             *\n             * @param  {String}  attribute\n             * @param  {Mixed}   value\n             * @return {Boolean}\n             */\n            Validator.prototype.validateInteger = function (attribute, value) {\n                return filter_var(value, FILTER_VALIDATE_INT) !== false;\n            };\n\n            /**\n             * Validate that an attribute is numeric.\n             *\n             * @param  {String}   attribute\n             * @param  {Mixed}    value\n             * @return {Boolean}\n             */\n            Validator.prototype.validateNumeric = function (attribute, value) {\n                return !isNaN(value);\n            };\n\n            /**\n             * Validate the size of an attribute is between a set of values.\n             *\n             * @param  {String}  attribute\n             * @param  {Mixed}   value\n             * @param  {Array}   parameters\n             * @return {Boolean}\n             */\n            Validator.prototype.validateBetween = function (attribute, value, parameters) {\n                this.requireParameterCount(2, parameters, 'between');\n\n                var size = this.getSize(attribute, value);\n\n                return size >= parameters[0] && size <= parameters[1];\n            };\n\n            /**\n             * Require a certain number of parameters to be present.\n             *\n             * @param  {Int}     count\n             * @param  {Array}   parameters\n             * @param  {String}  rule\n             * @return {undefined}\n             * @throws {Error}\n             */\n            Validator.prototype.requireParameterCount = function (count, parameters, rule) {\n                if (parameters.length < count) {\n                    throw new Error(\"Validation rule \" + rule + \" requires at least \" + count + \" parameters.\");\n                }\n            };\n\n            /**\n             * Get the size of an attribute.\n             *\n             * @param  {String}  attribute\n             * @param  {Mixed}   value\n             * @return {Mixed}\n             */\n            Validator.prototype.getSize = function (attribute, value) {\n                var hasNumeric = this.hasRule(attribute, this.numericRules);\n\n                // This method will determine if the attribute is a number, string, or file and\n                // return the proper size accordingly. If it is a number, then number itself\n                // is the size. If it is a file, we take kilobytes, and for a string the\n                // entire length of the string will be considered the attribute size.\n                if (!isNaN(value) && hasNumeric) {\n                    return this.data[attribute];\n                } else if (Array.isArray(value)) {\n                    return value.length > 0;\n                }\n\n                return this.getStringSize(value);\n            };\n\n            /**\n             * Get the size of a string.\n             *\n             * @param  {String}  value\n             * @return {Int}\n             */\n            Validator.prototype.getStringSize = function (value) {\n                if (value) {\n                    return ('' + value).trim().length;\n                };\n\n                return 0;\n            };\n\n            /**\n             * Determine if the given attribute has a rule in the given set.\n             *\n             * @param  {String}          attribute\n             * @param  {String|Object}   rules\n             * @return {Boolean}\n             */\n            Validator.prototype.hasRule = function (attribute, rules) {\n                return !!this.getRule(attribute, rules);\n            }\n\n            /**\n             * Get a rule and its parameters for a given attribute.\n             *\n             * @param  {String}         attribute\n             * @param  {String|Object}  rules\n             * @return {Object|undefined}\n             */\n            Validator.prototype.getRule = function (attribute, rules) {\n                if (!this.rules[attribute]) {\n                    return;\n                }\n\n                for (var rule in this.rules) {\n                    var parsed = this.parseRule(this.rules[rule]);\n\n                    if (rules.indexOf(parsed.rule) !== -1) {\n                        return parsed;\n                    };\n                };\n            };\n\n            /**\n             * Get the displayable name of the attribute.\n             *\n             * @param  {String}  attribute\n             * @return {String}\n             */\n            Validator.prototype.getAttribute = function (attribute) {\n                // The developer may dynamically specify the array of custom attributes\n                // on this Validator instance. If the attribute exists in this array\n                // it takes precedence over all other ways we can pull attributes.\n                if (this.customAttributes[attribute]) {\n                    return this.customAttributes[attribute];\n                }\n\n                var key = 'attributes.' + attribute;\n                // We allow for the developer to specify language messages for each of the\n                // attributes allowing for more displayable counterparts of each of\n                // the attributes. This provides the ability for simple formats.\n\n                var message = ValidationTranslator.trans(key)\n\n                if (message !== key) {\n                    return message;\n                }\n\n                // If no language message has been specified for the attribute all of the\n                // underscores are removed from the attribute name and that will be\n                // used as default versions of the attribute's displayable names.\n                return snakeCase(attribute).replace(/_/g, ' ');\n            };\n\n            /**\n             * Get the data type of the given attribute.\n             *\n             * @param  {String}  attribute\n             * @return {String}\n             */\n            Validator.prototype.getAttributeType = function (attribute) {\n                if (this.hasRule(attribute, this.numericRules)) {\n                    return 'numeric';\n                } else if (this.hasRule(attribute, 'Array')) {\n                    return 'array';\n                }\n\n                return 'string';\n            };\n\n            /**\n             * Transform an array of attributes to their displayable form.\n             *\n             * @param  {Array}  values\n             * @return {Array}\n             */\n            Validator.prototype.getAttributeList = function (values) {\n                var attributes = [];\n\n                // For each attribute in the list we will simply get its displayable form as\n                // this is convenient when replacing lists of parameters like some of the\n                // replacement functions do when formatting out the validation message.\n                for (var i = 0; i < values.length; i++) {\n                    attributes.push(this.getAttribute(values[i]));\n                };\n\n                return attributes;\n            };\n\n            /**\n             * Get the displayable name of the value.\n             *\n             * @param  {String}  attribute\n             * @param  {Mixed}   value\n             * @return {String}\n             */\n            Validator.prototype.getDisplayableValue = function (attribute, value) {\n                if (this.customValues[attribute] && this.customValues[attribute][value]) {\n                    return this.customValues[attribute][value];\n                }\n\n                var key = 'values.' + attribute + '.' + value;\n\n                var message = ValidationTranslator.trans(key);\n\n                if (message !== key) {\n                    return message;\n                };\n\n                return value;\n            };\n\n            /**\n             * Replace all place-holders for the between rule.\n             *\n             * @param  {String}  message\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @param  {Array}   parameters\n             * @return {String}\n             */\n            Validator.prototype.replaceBetween = function (message, attribute, rule, parameters) {\n                return message.replace(':min', parameters[0]).replace(':max', parameters[1]);\n            };\n\n            /**\n             * Replace all place-holders for the size rule.\n             *\n             * @param  {String}  message\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @param  {Array}   parameters\n             * @return {String}\n             */\n            Validator.prototype.replaceSize = function (message, attribute, rule, parameters) {\n                return message.replace(':size', parameters[0]);\n            };\n\n            /**\n             * Replace all place-holders for the min rule.\n             *\n             * @param  {String}  message\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @param  {Array}   parameters\n             * @return {String}\n             */\n            Validator.prototype.replaceMin = function (message, attribute, rule, parameters) {\n                return message.replace(':min', parameters[0]);\n            };\n\n            /**\n             * Replace all place-holders for the max rule.\n             *\n             * @param  {String}  message\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @param  {Array}   parameters\n             * @return {String}\n             */\n            Validator.prototype.replaceMax = function (message, attribute, rule, parameters) {\n                return message.replace(':max', parameters[0]);\n            };\n\n            /**\n             * Replace all place-holders for the in rule.\n             *\n             * @param  {String}  message\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @param  {Array}   parameters\n             * @return {String}\n             */\n            Validator.prototype.replaceIn = function (message, attribute, rule, parameters) {\n                for (var i = 0; i < parameters.length; i++) {\n                    parameters[i] = this.getDisplayableValue(attribute, parameters[i]);\n                };\n\n                return message.replace(':values', parameters.join(', '));\n            };\n\n            /**\n             * Replace all place-holders for the not_in rule.\n             *\n             * @param  {String}  message\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @param  {Array}   parameters\n             * @return {String}\n             */\n            Validator.prototype.replaceNotIn = function (message, attribute, rule, parameters) {\n                return this.replaceIn(message, attribute, rule, parameters);\n            };\n\n            /**\n             * Replace all place-holders for the required_with rule.\n             *\n             * @param  {String}  message\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @param  {Array}   parameters\n             * @return {String}\n             */\n            Validator.prototype.replaceRequiredWith = function (message, attribute, rule, parameters) {\n                parameters = this.getAttributeList(parameters);\n                return message.replace(':values', parameters.join(' / '));\n            };\n\n            /**\n             * Replace all place-holders for the required_without rule.\n             *\n             * @param  {String}  message\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @param  {Array}   parameters\n             * @return {String}\n             */\n            Validator.prototype.replaceRequiredWithout = function (message, attribute, rule, parameters) {\n                return this.replaceRequiredWith(message, attribute, rule, parameters);\n            };\n\n            /**\n             * Replace all place-holders for the required_without_all rule.\n             *\n             * @param  {String}  message\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @param  {Array}   parameters\n             * @return {String}\n             */\n            Validator.prototype.replaceRequiredWithoutAll = function (message, attribute, rule, parameters) {\n                return this.replaceRequiredWith(message, attribute, rule, parameters);\n            };\n\n            /**\n             * Replace all place-holders for the required_if rule.\n             *\n             * @param  {String}  message\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @param  {Array}   parameters\n             * @return {String}\n             */\n            Validator.prototype.replaceRequiredIf = function (message, attribute, rule, parameters) {\n                parameters[1] = this.getDisplayableValue(parameters[0], array_get(this.data, parameters[0]));\n                parameters[0] = this.getAttribute(parameters[0]);\n\n                return message.replace(':other', parameters[0]).replace(':value', parameters[1]);\n            };\n\n            /**\n             * Replace all place-holders for the same rule.\n             *\n             * @param  {String}  message\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @param  {Array}   parameters\n             * @return {String}\n             */\n            Validator.prototype.replaceSame = function (message, attribute, rule, parameters) {\n                return message.replace(':other', this.getAttribute(parameters[0]));\n            };\n\n            /**\n             * Replace all place-holders for the different rule.\n             *\n             * @param  {String}  message\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @param  {Array}   parameters\n             * @return {String}\n             */\n            Validator.prototype.replaceDifferent = function (message, attribute, rule, parameters) {\n                return this.replaceSame(message, attribute, rule, parameters);\n            };\n\n            /**\n             * Replace all place-holders for the date_format rule.\n             *\n             * @param  {String}  message\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @param  {Array}   parameters\n             * @return {String}\n             */\n            Validator.prototype.replaceDateFormat = function (message, attribute, rule, parameters) {\n                return message.replace(':format', parameters[0]);\n            };\n\n            /**\n             * Replace all place-holders for the before rule.\n             *\n             * @param  {String}  message\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @param  {Array}   parameters\n             * @return {String}\n             */\n            Validator.prototype.replaceBefore = function (message, attribute, rule, parameters) {\n                if (!Date.parse(parameters[0])) {\n                    return message.replace(':date', this.getAttribute(parameters[0]));\n                }\n                return message.replace(':date', parameters[0]);\n            };\n\n            /**\n             * Replace all place-holders for the after rule.\n             *\n             * @param  {String}  message\n             * @param  {String}  attribute\n             * @param  {String}  rule\n             * @param  {Array}   parameters\n             * @return {String}\n             */\n            Validator.prototype.replaceAfter = function (message, attribute, rule, parameters) {\n                return this.replaceBefore(message, attribute, rule, parameters);\n            };\n\n            /**\n             * Helper functions\n             */\n\n            /**\n             * Function to convert each word`s first letter to upper case.\n             *\n             * @param  {String}  str\n             * @return {String}\n             */\n            function ucwords(str) {\n                //  discuss at: http://phpjs.org/functions/ucwords/\n                // original by: Jonas Raoni Soares Silva (http://www.jsfromhell.com)\n                // improved by: Waldo Malqui Silva (http://waldo.malqui.info)\n                // improved by: Robin\n                // improved by: Kevin van Zonneveld (http://kevin.vanzonneveld.net)\n                // bugfixed by: Onno Marsman\n                //    input by: James (http://www.james-bell.co.uk/)\n                //   example 1: ucwords('kevin van  zonneveld');\n                //   returns 1: 'Kevin Van  Zonneveld'\n                //   example 2: ucwords('HELLO WORLD');\n                //   returns 2: 'HELLO WORLD'\n\n                return (str + '').replace(/^([a-z\\u00E0-\\u00FC])|\\s+([a-z\\u00E0-\\u00FC])/g, function ($1) {\n                    return $1.toUpperCase();\n                });\n            };\n\n            /**\n             * Function to convert text into studly case.\n             *\n             * @param  {String}  str\n             * @return {String}\n             */\n            function studlyCase(str) {\n                str = ucwords((str + '').replace(/[-_]/g, ' '));\n                return str.replace(/[\\s]/g, '');\n            };\n\n            /**\n             * Function to convert text into snake case.\n             *\n             * @param  {String}  str\n             * @return {String}\n             */\n            function snakeCase(str) {\n                return (str + '').replace(/(.)([A-Z])/g, '$1_$2').toLowerCase();\n            };\n\n            function replace(str, data) {\n                return str.replace(/:([A-z]*)/g,\n                    function (a, b) {\n                        var r = data[b];\n                        return typeof r === 'string' || typeof r === 'number' ? r : a;\n                    }\n                );\n            };\n\n            return Validator;\n        }\n    ]);",null],"sourceRoot":"/source/"}